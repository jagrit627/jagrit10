<!DOCTYPE html>
<!-- saved from url=(0093)file:///C:/Users/Lenovo/Downloads/JAGRIT%20WANNA%20TRY%20SOMETHING/class%2012.html#unit-cprog -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computer Science Hub</title>
    <style>
        /* Reset & Global */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: #f0f4f8;
            color: #333;
            line-height: 1.6;
        }

        a {
            text-decoration: none;
        }

        /* Header */
        header {
            background: linear-gradient(135deg, #1abc9c, #16a085);
            color: white;
            text-align: center;
            padding: 25px 10px;
            font-size: 26px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        /* Layout */
        .container {
            display: flex;
            gap: 20px;
            padding: 25px;
            flex-wrap: wrap;
        }

        /* Syllabus Sidebar */
        aside.syllabus {
            flex: 1 1 250px;
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.08);
            position: sticky;
            top: 20px;
            height: fit-content;
            transition: transform 0.3s;
        }

        aside.syllabus:hover {
            transform: translateY(-5px);
        }

        aside.syllabus h3 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 22px;
            color: #16a085;
            border-bottom: 2px solid #1abc9c;
            padding-bottom: 10px;
        }

        aside.syllabus ul {
            list-style: none;
        }

        aside.syllabus ul li {
            margin: 12px 0;
        }

        aside.syllabus ul li a {
            color: #1abc9c;
            font-weight: 500;
            transition: color 0.3s, padding-left 0.3s;
        }

        aside.syllabus ul li a:hover {
            color: #e74c3c;
            padding-left: 5px;
        }

        /* Main Content */
        main {
            flex: 3 1 700px;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.08);
        }

        h2 {
            font-size: 26px;
            color: #16a085;
            margin-bottom: 15px;
            border-bottom: 3px solid #1abc9c;
            padding-bottom: 5px;
        }

        h3 {
            font-size: 20px;
            margin-top: 25px;
            color: #34495e;
        }

        p, ul {
            margin: 12px 0;
        }

        ul li {
            margin-bottom: 10px;
        }

        /* Code & Pre */
        pre {
            background: #1e1e2f;
            color: #f8f8f2;
            padding: 18px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 20px 0;
            font-size: 14px;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.2);
        }

        code {
            font-family: 'Courier New', monospace;
        }

        /* Table Styling */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px 15px;
            border: 1px solid #ddd;
            text-align: left;
        }

        th {
            background: #16a085;
            color: white;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 18px;
            background: linear-gradient(135deg, #1abc9c, #16a085);
            color: white;
            margin-top: 40px;
            font-weight: 500;
        }

        /* Responsive */
        @media(max-width: 900px) {
            .container {
                flex-direction: column;
            }
        }

    </style>
</head>
<body>
    <header>
        Computer Science Academic Hub
    </header>

    <div class="container">
        <!-- Syllabus -->
        <aside class="syllabus">
            <h3>Syllabus</h3>
            <ul>
                <li><a href="file:///C:/Users/Lenovo/Downloads/JAGRIT%20WANNA%20TRY%20SOMETHING/class%2012.html#unit-database">UNIT 1. Database</a></li>
                <li><a href="file:///C:/Users/Lenovo/Downloads/JAGRIT%20WANNA%20TRY%20SOMETHING/class%2012.html#unit-networking">UNIT 2. Networking</a></li>
                <li><a href="file:///C:/Users/Lenovo/Downloads/JAGRIT%20WANNA%20TRY%20SOMETHING/class%2012.html#unit-webtech">UNIT 3. Web Technology II</a></li>
                <li><a href="file:///C:/Users/Lenovo/Downloads/JAGRIT%20WANNA%20TRY%20SOMETHING/class%2012.html#unit-cprog">UNIT 4. Programming in C</a></li>
                <li><a href="file:///C:/Users/Lenovo/Downloads/JAGRIT%20WANNA%20TRY%20SOMETHING/class%2012.html#unit-oop">UNIT 5. Object Oriented Programming</a></li>
                <li><a href="file:///C:/Users/Lenovo/Downloads/JAGRIT%20WANNA%20TRY%20SOMETHING/class%2012.html#unit-software">UNIT 6. Software Process Model</a></li>
                <li><a href="file:///C:/Users/Lenovo/Downloads/JAGRIT%20WANNA%20TRY%20SOMETHING/class%2012.html#unit-trends">UNIT 7. Recent Trends in Technology</a></li>
            </ul>
        </aside>

        <!-- Main Content -->
        <main>
            <!-- DBMS Chapter -->
            <section id="unit-database">
            
                <h1>Database Management System (DBMS)</h1>


                <h2>1. Data, Information, Features of Information</h2>
                <p><strong>Data:</strong> Raw facts or figures without context.</p>
                <p><strong>Information:</strong> Processed data that is meaningful and useful.</p>
                <p><strong>Features of Information:</strong></p>
                <ul>
                    <li>Accuracy</li>
                    <li>Relevance</li>
                    <li>Timeliness</li>
                    <li>Completeness</li>
                </ul>


                <h2>2. Database and its Purpose</h2>
                <p>A database is an organized collection of related data. Its purpose is to efficiently store, retrieve,
                    and manage data.</p>


                <h2>3. Terminologies in Database</h2>
                <ul>
                    <li><strong>Table:</strong> A collection of related data entries organized in rows and columns.</li>
                    <li><strong>Field:</strong> A single piece of data; a column in a table.</li>
                    <li><strong>Record:</strong> A complete set of fields; a row in a table.</li>
                    <li><strong>Tuple:</strong> Another name for a record (a row).</li>
                    <li><strong>Object:</strong> An entity that represents data and behavior (used in object-oriented
                        databases).</li>
                    <li><strong>Keys:</strong> Attributes that uniquely identify a record in a table.</li>
                </ul>


                <h2>4. Data Types</h2>
                <p>Data types define the kind of data that can be stored in a field, e.g., Integer, Float, Char, Date,
                    etc.</p>


                <h2>5. Data Dictionary</h2>
                <p>A data dictionary contains metadata about the database, such as structure, constraints, and
                    relationships.</p>


                <h2>6. Database Management System</h2>
                <ul>
                    <li><strong>Introduction:</strong> Software that manages databases and provides an interface for
                        users and applications.</li>
                    <li><strong>Objectives:</strong> To store data securely, allow easy access, and maintain data
                        integrity.</li>
                    <li><strong>Advantages:</strong> Data sharing, security, consistency, and reduced redundancy.</li>
                    <li><strong>Disadvantages:</strong> Cost, complexity, and possible performance overhead.</li>
                </ul>


                <h2>7. Types of Database Model</h2>
                <ul>
                    <li><strong>Hierarchical:</strong> Data organized in a tree-like structure.</li>
                    <li><strong>Network:</strong> Flexible graph structure allowing many-to-many relationships.</li>
                    <li><strong>Relational:</strong> Data stored in tables with relationships using keys.</li>
                    <li><strong>Entity-Relational:</strong> Uses entity-relationship diagrams to model data.</li>
                </ul>


                <h2>8. Integrity Constraints and Types</h2>
                <ul>
                    <li><strong>Domain:</strong> Restricts the type of data that can be stored in a field.</li>
                    <li><strong>Entity:</strong> Ensures each entity has a unique identity.</li>
                    <li><strong>Referential:</strong> Ensures relationships between tables remain consistent.</li>
                    <li><strong>Keys:</strong> Uniquely identify records to maintain data integrity.</li>
                </ul>


                <h2>9. Normalization</h2>
                <h3>Introduction</h3>
                <p>Normalization is the process of organizing data to reduce redundancy and improve integrity.</p>
                <h3>Normal Forms</h3>
                <ul>
                    <li><strong>1NF:</strong> Eliminate repeating groups; each field contains atomic values.</li>
                    <li><strong>2NF:</strong> Remove partial dependencies on a composite key.</li>
                    <li><strong>3NF:</strong> Remove transitive dependencies.</li>
                </ul>
                <h3>Advantages</h3>
                <ul>
                    <li>Reduces data redundancy.</li>
                    <li>Improves data integrity.</li>
                    <li>Efficient data organization.</li>
                </ul>
                <h3>Disadvantages</h3>
                <ul>
                    <li>Can increase complexity of queries.</li>
                    <li>May require more joins in relational databases.</li>
                </ul>
                
                


                
                    
                    <title>Database Management System Detailed Topics</title>
                


                
                    <h1>Database Management System (DBMS) Detailed Topics</h1>


                    <h2>10. DBA and Roles of DBA</h2>
                    <p><strong>DBA (Database Administrator)</strong> is a professional responsible for the installation,
                        configuration, design, security, and maintenance of a database management system (DBMS). The DBA
                        ensures that the database environment operates efficiently, securely, and reliably, meeting the
                        needs of the organization.</p>


                    <h3>Key Responsibilities and Roles of a DBA</h3>
                    <ul>
                        <li>
                            <strong>Installation and Configuration:</strong> The DBA installs the DBMS software, sets up
                            database instances, and configures system parameters to optimize performance and resource
                            use.
                        </li>
                        <li>
                            <strong>Database Design and Schema Creation:</strong> The DBA collaborates with database
                            designers and developers to create logical and physical database schemas, including tables,
                            indexes, relationships, and constraints.
                        </li>
                        <li>
                            <strong>Data Security Management:</strong> The DBA controls access to the database by
                            defining user roles, privileges, and permissions, ensuring sensitive data is protected
                            against unauthorized access or breaches.
                        </li>
                        <li>
                            <strong>Backup and Recovery:</strong> The DBA plans and implements backup strategies to
                            protect data from loss, and develops recovery plans and procedures to restore the database
                            to a consistent state after failures.
                        </li>
                        <li>
                            <strong>Performance Monitoring and Tuning:</strong> The DBA monitors database performance
                            metrics, analyzes slow queries, optimizes SQL commands, and adjusts system configurations to
                            maintain optimal speed and efficiency.
                        </li>
                        <li>
                            <strong>User Management:</strong> The DBA creates and manages database user accounts,
                            enforces password policies, and audits user activities to ensure compliance with
                            organizational policies.
                        </li>
                        <li>
                            <strong>Data Integrity and Consistency:</strong> The DBA enforces rules and constraints that
                            maintain the accuracy and reliability of data throughout its lifecycle.
                        </li>
                        <li>
                            <strong>Upgrades and Patch Management:</strong> The DBA applies patches, updates, and
                            upgrades to the DBMS software to fix bugs, improve functionality, and protect against
                            vulnerabilities.
                        </li>
                        <li>
                            <strong>Documentation and Reporting:</strong> The DBA maintains detailed documentation of
                            database configurations, policies, procedures, and issues, and provides regular reports to
                            stakeholders.
                        </li>
                    </ul>


                    <p><em>In summary, the DBA plays a critical role in ensuring the database is secure, available, and
                            performing well, thereby supporting the organization's data management and business
                            needs.</em></p>


                    <hr>


                    <h2>11. ER Diagrams (Entity-Relationship Diagrams)</h2>


                    <h3>Introduction</h3>
                    <p>An <strong>Entity-Relationship Diagram (ER Diagram)</strong> is a graphical representation of
                        entities and their relationships within a database system. ER diagrams are widely used during
                        the database design phase to visualize the structure and constraints of the data model before
                        implementation.</p>
                    <p>The ER diagram helps database designers and stakeholders understand the organization of data,
                        relationships between different entities, and the rules that govern those relationships.</p>


                    <h3>Key Components of ER Diagrams</h3>
                    <ul>
                        <li>
                            <strong>Entity:</strong> Represents a real-world object or concept that can have data stored
                            about it. For example, a "Student," "Course," or "Employee" could be entities. Entities are
                            typically represented by rectangles.
                        </li>
                        <li>
                            <strong>Attributes:</strong> Describe properties or characteristics of entities. For
                            example, a Student entity might have attributes such as StudentID, Name, Date of Birth, and
                            Email. Attributes are usually shown as ovals connected to their entities.
                        </li>
                        <li>
                            <strong>Relationships:</strong> Show associations between two or more entities. For
                            instance, a "Registers" relationship might link Students and Courses to represent
                            enrollment. Relationships are depicted as diamonds connecting entities.
                        </li>
                        <li>
                            <strong>Cardinality:</strong> Defines the number of instances of one entity that can be
                            associated with instances of another entity. Common cardinalities include:
                            <ul>
                                <li>One-to-One (1:1)</li>
                                <li>One-to-Many (1:N)</li>
                                <li>Many-to-Many (M:N)</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Degree:</strong> Refers to the number of participating entities in a relationship.
                            Most relationships are binary (degree 2), but ternary (degree 3) and higher are possible.
                        </li>
                    </ul>


                    <h3>Common Symbols Used in ER Diagrams and Their Meanings</h3>
                    <ul>
                        <li><strong>Rectangle:</strong> Represents an <em>Entity</em>.</li>
                        <li><strong>Oval:</strong> Represents an <em>Attribute</em> of an entity or relationship.</li>
                        <li><strong>Diamond:</strong> Represents a <em>Relationship</em> between entities.</li>
                        <li><strong>Double Oval:</strong> Represents a <em>Multivalued Attribute</em>, meaning an
                            attribute can have multiple values for a single entity instance (e.g., phone numbers).</li>
                        <li><strong>Dashed Oval:</strong> Represents a <em>Derived Attribute</em>, whose value can be
                            calculated from other attributes (e.g., age from date of birth).</li>
                        <li><strong>Double Rectangle:</strong> Represents a <em>Weak Entity</em>, which depends on
                            another entity for its existence and does not have a key attribute on its own.</li>
                        <li><strong>Double Diamond:</strong> Represents an <em>Identifying Relationship</em> that links
                            a weak entity to its owner entity.</li>
                        <li><strong>Lines:</strong> Connect entities to relationships and attributes to entities or
                            relationships. The lines may have symbols or numbers indicating cardinality.</li>
                        <li><strong>Cardinality Notation:</strong> Usually represented near the connecting lines with
                            symbols such as:</li>
                        <ul>
                            <li><em>1</em> — Exactly one instance</li>
                            <li><em>0..1</em> — Zero or one instance (optional)</li>
                            <li><em>0..*</em> or <em>0..n</em> — Zero or many instances</li>
                            <li><em>1..*</em> or <em>1..n</em> — One or many instances</li>
                        </ul>
                    </ul>


                    <h3>Example Scenario</h3>
                    <p>Consider a university database where:</p>
                    <ul>
                        <li><strong>Entities:</strong> Student, Course, Instructor</li>
                        <li><strong>Attributes:</strong> Student has StudentID, Name, Email; Course has CourseID, Title,
                            Credits; Instructor has InstructorID, Name</li>
                        <li><strong>Relationships:</strong> "Enrolls" between Student and Course; "Teaches" between
                            Instructor and Course</li>
                        <li><strong>Cardinality:</strong> One student can enroll in many courses (1:N), a course can
                            have many students (M:N); one instructor can teach many courses (1:N)</li>
                    </ul>
                    <p>An ER diagram would visually represent this structure to help create the relational schema later.
                    </p>


                    <h3>Importance of ER Diagrams</h3>
                    <ul>
                        <li>Helps in clearly visualizing data requirements and relationships.</li>
                        <li>Facilitates communication between developers, DBAs, and stakeholders.</li>
                        <li>Acts as a blueprint for database design and implementation.</li>
                        <li>Reduces errors and improves understanding before coding begins.</li>
                    </ul>


                    <hr>


                    <p><em>This concludes the detailed explanation of DBA roles and ER diagrams in database management
                            systems.</em></p>
                


                
                    
                    


                    
                        
                        <title>SQL Concepts Explained</title>
                    


                    
                        <h1>SQL Concepts</h1>


                        <h2>1. SQL (Structured Query Language)</h2>
                        <p>SQL is a standard language used to communicate with and manipulate databases.</p>


                        <h3>1.1 Data Definition Language (DDL)</h3>
                        <p>DDL commands are used to define or modify database structure.</p>
                        <ul>
                            <li><strong>CREATE:</strong> Creates database objects like tables, indexes, or databases.
                            </li>
                            <li><strong>ALTER:</strong> Modifies existing database objects, e.g., adding columns to a
                                table.</li>
                            <li><strong>DROP:</strong> Deletes database objects like tables or databases.</li>
                            <li><strong>TRUNCATE:</strong> Removes all records from a table, but keeps the structure.
                            </li>
                        </ul>


                        <h3>1.2 Data Manipulation Language (DML)</h3>
                        <p>DML commands are used to manage data stored in database objects.</p>
                        <ul>
                            <li><strong>SELECT:</strong> Retrieves data from the database.</li>
                            <li><strong>INSERT:</strong> Adds new rows into a table.</li>
                            <li><strong>UPDATE:</strong> Modifies existing data within a table.</li>
                            <li><strong>DELETE:</strong> Removes existing records from a table.</li>
                        </ul>


                        <hr>


                        <h2>2. Data Constraints</h2>
                        <p>Constraints enforce rules on data columns in a table to ensure data integrity.</p>
                        <ul>
                            <li><strong>NOT NULL:</strong> Ensures a column cannot have NULL (empty) values.</li>
                            <li><strong>UNIQUE:</strong> Ensures all values in a column are distinct (no duplicates).
                            </li>
                            <li><strong>PRIMARY KEY:</strong> Uniquely identifies each record in a table; combines NOT
                                NULL and UNIQUE constraints.</li>
                            <li><strong>AUTO INCREMENT:</strong> Automatically generates a unique number for new rows,
                                often used for primary keys.</li>
                        </ul>


                        <hr>


                        <h2>3. Operators in SQL</h2>
                        <p>Logical operators are used to combine multiple conditions in SQL queries.</p>
                        <ul>
                            <li><strong>AND:</strong> Returns TRUE if both conditions are TRUE.</li>
                            <li><strong>OR:</strong> Returns TRUE if at least one condition is TRUE.</li>
                            <li><strong>NOT:</strong> Negates a condition; returns TRUE if the condition is FALSE.</li>
                        </ul>


                        <hr>


                        <h2>4. WHERE Clause</h2>
                        <p>The <strong>WHERE</strong> clause is used to filter records that satisfy a specified
                            condition.</p>
                        <p><strong>Syntax Example:</strong></p>
                        <pre>SELECT column1, column2
FROM table_name
WHERE condition;
  </pre>
                        <p><strong>Example:</strong> Select students with age greater than 18</p>
                        <pre>SELECT * FROM Students
WHERE Age &gt; 18;
  </pre>


                        <hr>


                        <h2>5. ORDER BY Clause</h2>
                        <p>The <strong>ORDER BY</strong> clause is used to sort the result set in ascending
                            (<code>ASC</code>) or descending (<code>DESC</code>) order based on one or more columns.</p>
                        <p><strong>Syntax Example:</strong></p>
                        <pre>SELECT column1, column2
FROM table_name
ORDER BY column1 ASC, column2 DESC;
  </pre>
                        <p><strong>Example:</strong> Select students and order them by last name ascending and age
                            descending:</p>
                        <pre>SELECT * FROM Students
ORDER BY LastName ASC, Age DESC;
  </pre>


                        
                        


                        
                            
                            <title>SQL JOIN Types Explained</title>
                        


                        
                            <h1>SQL JOINs</h1>
                            <p>SQL JOIN is used to combine rows from two or more tables based on a related column
                                between them.</p>


                            <h2>1. INNER JOIN</h2>
                            <p>Returns only the rows where there is a match in both tables.</p>
                            <h3>Example:</h3>
                            <p>Get the list of students along with the courses they are enrolled in.</p>
                            <pre>SELECT Students.StudentID, Students.Name, Enrollments.CourseID
FROM Students
INNER JOIN Enrollments ON Students.StudentID = Enrollments.StudentID;
  </pre>


                            <h2>2. LEFT JOIN (or LEFT OUTER JOIN)</h2>
                            <p>Returns all rows from the left table, and the matched rows from the right table. If no
                                match, NULL values are returned for the right table.</p>
                            <h3>Example:</h3>
                            <p>Get all students and their courses. If a student is not enrolled in any course, show
                                NULL.</p>
                            <pre>SELECT Students.StudentID, Students.Name, Enrollments.CourseID
FROM Students
LEFT JOIN Enrollments ON Students.StudentID = Enrollments.StudentID;
  </pre>


                            <h2>3. RIGHT JOIN (or RIGHT OUTER JOIN)</h2>
                            <p>Returns all rows from the right table, and the matched rows from the left table. If no
                                match, NULL values are returned for the left table.</p>
                            <h3>Example:</h3>
                            <p>Get all course enrollments and students. If a course has no students enrolled, show NULL
                                for student details.</p>
                            <pre>SELECT Students.StudentID, Students.Name, Enrollments.CourseID
FROM Students
RIGHT JOIN Enrollments ON Students.StudentID = Enrollments.StudentID;
  </pre>


                            <h2>4. FULL JOIN (or FULL OUTER JOIN)</h2>
                            <p>Returns all rows when there is a match in either left or right table. If no match in one
                                table, returns NULLs for that table.</p>
                            <h3>Example:</h3>
                            <p>Get all students and courses from enrollments, including students not enrolled and
                                courses with no students.</p>
                            <pre>SELECT Students.StudentID, Students.Name, Enrollments.CourseID
FROM Students
FULL OUTER JOIN Enrollments ON Students.StudentID = Enrollments.StudentID;
  </pre>


                            <hr>
                            <h2>Summary Table</h2>
                            <table border="1" cellpadding="5" cellspacing="0">
                                <thead>
                                    <tr>
                                        <th>JOIN Type</th>
                                        <th>Description</th>
                                        <th>Rows Returned</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>INNER JOIN</td>
                                        <td>Rows matching in both tables</td>
                                        <td>Only matching rows</td>
                                    </tr>
                                    <tr>
                                        <td>LEFT JOIN</td>
                                        <td>All rows from left table + matching rows from right</td>
                                        <td>All left rows + matched right rows</td>
                                    </tr>
                                    <tr>
                                        <td>RIGHT JOIN</td>
                                        <td>All rows from right table + matching rows from left</td>
                                        <td>All right rows + matched left rows</td>
                                    </tr>
                                    <tr>
                                        <td>FULL JOIN</td>
                                        <td>All rows from both tables, matched or unmatched</td>
                                        <td>All rows from left and right tables</td>
                                    </tr>
                                </tbody>
                            </table>
                        


                        



                    


                    


                


            




        


        


            <!-- C Programming Chapter -->
            <section id="unit-cprog">
                <h2>UNIT 4. Programming in C</h2>
                
        <h3><strong>Just for reminder, Let's revise Class 11</strong></h3>


        <ol>
            <li><strong>Introduction to C Programming</strong>
                <ol>
                    <li><em>a.Definition</em></li>
                    <li><em>b. History</em></li>
                </ol>
            </li>
            <li><strong>Functions</strong></li>
            <li><strong>Components of Function</strong></li>
            <li><strong>Structure and Union</strong></li>
            <li><strong>Pointers</strong></li>
            <li><strong>File Handling</strong></li>
        </ol>
        

<h3><strong>Just for reminder, Let's revise Class 11</strong></h3>
        <h2><strong>Introduction to C Programming</strong></h2>


        <p>C is a powerful general-purpose programming language that is widely used for system and application software
            development. It was developed in the early 1970s and has influenced many other programming languages.</p>


        <h3><strong>Features of C Programming</strong></h3>
        <ul>
            <li><strong>Simple and Efficient:</strong> C provides low-level access to memory and is simple to learn.
            </li>
            <li><strong>Portable:</strong> Programs written in C can run on different machines with little or no
                modification.</li>
            <li><strong>Structured Language:</strong> Supports modular programming using functions for better code
                management.</li>
            <li><strong>Rich Library:</strong> Provides a wide range of built-in functions for common operations.</li>
            <li><strong>Speed:</strong> C programs execute quickly, making it suitable for performance-critical
                applications.</li>
            <li><strong>Memory Management:</strong> Allows direct manipulation of memory using pointers.</li>
        </ul>


        <h3><strong>History of C Programming</strong></h3>
        <p>C was developed by Dennis Ritchie at Bell Labs between 1969 and 1973. It was designed to develop the UNIX
            operating system. Since then, it has become one of the most widely used programming languages of all time
            and has greatly influenced many modern languages like C++, Java, and C#.</p>


        <h1> Functions</h1>
        <img src="./Computer Science Hub_files/function-in-programming-768.jpg" alt="Alt text">
        <h4> Introduction To Functions</h4>
        
        


        
            
            <title>Functions in C Programming</title>
        


        
            <h1><strong>Functions in C Programming</strong></h1>


            <h2>Introduction and Syntax</h2>
            <p>A function is a block of code that performs a specific task. It helps break down a program into smaller,
                manageable, and reusable parts.</p>
            <p><strong>Basic Syntax:</strong></p>
            <pre>return_type function_name(parameter_list) {
    // body of the function
}
  </pre>


            <h2>Purpose and Advantages of Functions</h2>
            <ul>
                <li>Modularity: Breaks down complex programs into smaller parts.</li>
                <li>Code Reusability: Functions can be called multiple times.</li>
                <li>Easier Maintenance: Simplifies debugging and updating code.</li>
                <li>Improves Readability: Organizes code in logical blocks.</li>
            </ul>


            <h2>Components of a Function</h2>
            <ul>
                <li><strong>Prototype:</strong> Declaration of the function specifying return type and parameters.</li>
                <li><strong>Function Definition:</strong> Actual body of the function where the task is performed.</li>
                <li><strong>Function Call:</strong> Invoking the function to execute the code inside it.</li>
                <li><strong>Return Statement:</strong> Returns a value from the function to the caller (optional).</li>
            </ul>


            <h2>Function Prototype</h2>
            <p>Declares the function before its usage, informing the compiler about the function’s name, return type,
                and parameters.</p>
            <pre>return_type function_name(parameter_list);</pre>


            <h2>Function Definition</h2>
            <p>The actual implementation of the function.</p>
            <pre>return_type function_name(parameter_list) {
    // function body
    return value; // if return type is not void
}
  </pre>


            <h2>Function Call</h2>
            <p>Executing the function by providing necessary arguments.</p>
            <pre>function_name(arguments);</pre>


            <h2>Return Statement</h2>
            <p>Used to return a value from the function to the caller.</p>
            <pre>return value;</pre>


            <h2>Types of Functions</h2>
            <ul>
                <li><strong>Library Functions:</strong> Predefined functions provided by C standard libraries (e.g.,
                    printf(), scanf()).</li>
                <li><strong>User-Defined Functions:</strong> Functions created by the programmer to perform specific
                    tasks.</li>
            </ul>


            <h2>Passing Arguments</h2>
            <p>Arguments can be passed to functions in two ways:</p>
            <ul>
                <li><strong>Call by Value:</strong> Copies the actual value to the function parameter. Changes inside
                    the function do not affect the original variable.</li>
                <li><strong>Call by Reference:</strong> Passes the address of the variable. Changes inside the function
                    affect the original variable.</li>
            </ul>


            <h2>Variable and its Scope</h2>
            <p>Scope defines the visibility of a variable within the program.</p>
            <ul>
                <li><strong>Local Variables:</strong> Declared inside a function/block and accessible only within that
                    function/block.</li>
                <li><strong>Global Variables:</strong> Declared outside all functions and accessible throughout the
                    program.</li>
            </ul>


            <h2>Storage Class</h2>
            <p>Specifies the lifetime, visibility, and location of variables.</p>
            <ul>
                <li><strong>Automatic (auto):</strong> Default for local variables; stored in stack, lifetime limited to
                    function execution.</li>
                <li><strong>External (extern):</strong> Used to declare global variables defined elsewhere.</li>
                <li><strong>Static:</strong> Retains value between function calls; local static variables have scope
                    limited to the function but lifetime through the program.</li>
                <li><strong>Register:</strong> Suggests that the variable be stored in CPU registers for faster access
                    (limited size and number).</li>
            </ul>



        02    <h1>Function with Array</h1>
            <p>Example of a function that takes an array as argument:</p>
            <pre><code>
void printArray(int arr[], int size) {
    for(int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}
int main() {
    int numbers[] = {1, 2, 3, 4, 5};
    printArray(numbers, 5);
    return 0;
}
    </code></pre>


            <h1>Recursive Function</h1>
            <h2>Syntax</h2>
            <pre><code>
return_type functionName(parameters) {
    if (base_condition) {
        // base case
        return value;
    } else {
        // recursive call
        return functionName(modified_parameters);
    }
}
    </code></pre>


            <h2>Code Example (Factorial)</h2>
            <pre><code>
int factorial(int n) {
    if (n == 0) {
        return 1;  // base case
    } else {
        return n * factorial(n - 1);  // recursive call
    }
}
    </code></pre>


            <h2>Advantages</h2>
            <ul>
                <li>Simplifies code for problems that have repetitive or nested structures.</li>
                <li>Helps in breaking complex problems into simpler sub-problems.</li>
                <li>Useful for tree and graph traversal algorithms.</li>
            </ul>


            <h2>Disadvantages</h2>
            <ul>
                <li>Can lead to high memory usage due to call stack overhead.</li>
                <li>Possibility of stack overflow if recursion depth is too deep.</li>
                <li>Sometimes less efficient compared to iterative solutions.</li>
            </ul>


            <h1>Structure and Union</h1>


            <h2>Structure</h2>


            <h3>Introduction and Syntax</h3>
            <p>A <code>structure</code> in C allows grouping variables of different data types under a single name.</p>
            <pre><code>
struct StructureName {
    dataType member1;
    dataType member2;
    // ...
};
    </code></pre>


            <h3>Structure Size</h3>
            <p>The size of a structure is the sum of the sizes of its members, possibly with padding for alignment.</p>


            <h3>Accessing Members of Structure</h3>
            <pre><code>
struct Point {
    int x;
    int y;
};


int main() {
    struct Point p1;
    p1.x = 10;
    p1.y = 20;
    printf("X = %d, Y = %d\n", p1.x, p1.y);
    return 0;
}
    </code></pre>


            <h3>Nested Structure</h3>
            <pre><code>
struct Date {
    int day;
    int month;
    int year;
};


struct Employee {
    char name[50];
    struct Date dob;
};


int main() {
    struct Employee emp = {"John Doe", {15, 6, 1990}};
    printf("Name: %s\n", emp.name);
    printf("DOB: %d/%d/%d\n", emp.dob.day, emp.dob.month, emp.dob.year);
    return 0;
}
    </code></pre>


            <h3>Array of Structure</h3>
            <pre><code>
struct Student {
    int id;
    char name[50];
};


int main() {
    struct Student students[3] = {
        {1, "Alice"},
        {2, "Bob"},
        {3, "Charlie"}
    };
    for(int i = 0; i &lt; 3; i++) {
        printf("ID: %d, Name: %s\n", students[i].id, students[i].name);
    }
    return 0;
}
    </code></pre>


            <h3>Passing Structure to Function</h3>
            <pre><code>
struct Rectangle {
    int length;
    int width;
};


int area(struct Rectangle r) {
    return r.length * r.width;
}


int main() {
    struct Rectangle rect = {10, 5};
    printf("Area: %d\n", area(rect));
    return 0;
}
    </code></pre>


            <h2>Union</h2>


            <h3>Introduction and Syntax</h3>
            <p>A <code>union</code> is similar to a structure but all members share the same memory location.</p>
            <pre><code>
union UnionName {
    dataType member1;
    dataType member2;
    // ...
};
    </code></pre>


            <h3>Comparison between Structure and Union</h3>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Structure</th>
                        <th>Union</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Memory Allocation</td>
                        <td>Each member has its own memory.</td>
                        <td>All members share the same memory location.</td>
                    </tr>
                    <tr>
                        <td>Size</td>
                        <td>Sum of sizes of all members (plus padding).</td>
                        <td>Size of largest member.</td>
                    </tr>
                    <tr>
                        <td>Usage</td>
                        <td>To store different types of data simultaneously.</td>
                        <td>To store one type of data at a time (saving memory).</td>
                    </tr>
                    <tr>
                        <td>Access</td>
                        <td>All members can be accessed at any time.</td>
                        <td>Only one member can be accessed at a time.</td>
                    </tr>
                    <tr>
                        <td>Initialization</td>
                        <td>Members can be initialized separately.</td>
                        <td>Only one member can be initialized at a time.</td>
                    </tr>
                </tbody>
            </table>
            
        </section></section></main>
    </div>
    


    <h1>C Programming: Pointers &amp; File Handling</h1>

    <section>
        <h2>Pointers</h2>

        <h3>Introduction and Syntax</h3>
        <p>A pointer is a variable that stores the memory address of another variable. Syntax:</p>
        <pre>type *pointerName;</pre>

        <h3>Usage and Working</h3>
        <p>Pointers are used to access and manipulate memory directly. They allow efficient array handling, dynamic memory allocation, and function argument passing by reference.</p>

        <h3>Concept of Value and Address</h3>
        <p>The value of a pointer is the address of the variable it points to. Using the dereference operator (*), we can access the value stored at that address.</p>

        <h3>Declaration and Initialization</h3>
        <pre>int *ptr;       // Declaration
int x = 10;
ptr = &amp;x;         // Initialization with address of x</pre>

        <h3>Pointer and Function with Code Example</h3>
        <pre>#include &lt;stdio.h&gt;

void increment(int *p) {
    (*p)++;
}

int main() {
    int a = 5;
    increment(&amp;a);
    printf("Value of a: %d", a);
    return 0;
}
        </pre>

        <h3>Call by Reference with Code Example</h3>
        <pre>#include &lt;stdio.h&gt;

void swap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

int main() {
    int a = 5, b = 10;
    swap(&amp;a, &amp;b);
    printf("a = %d, b = %d", a, b);
    return 0;
}
        </pre>

        <h3>Comparison: Call by Value vs Call by Reference</h3>
        <ul>
            <li>Call by Value: Passes a copy of variable; original value remains unchanged.</li>
            <li>Call by Reference: Passes address of variable; changes affect the original variable.</li>
        </ul>

        <h3>Pointer with Arrays with Code Example</h3>
        <pre>#include &lt;stdio.h&gt;

int main() {
    int arr[3] = {1, 2, 3};
    int *ptr = arr;

    for(int i=0; i&lt;3; i++) {
        printf("%d ", *(ptr+i));
    }
    return 0;
}
        </pre>

        <h3>Advantages and Disadvantages</h3>
        <ul>
            <li>Advantages: Efficient memory usage, dynamic memory allocation, faster execution.</li>
            <li>Disadvantages: Complex code, risk of memory leaks, dangling pointers.</li>
        </ul>
    </section>

    <section>
        <h2>File Handling in C</h2>

        <h3>Concept of Data File</h3>
        <p>A data file is a collection of information stored on disk for later use by programs.</p>

        <h3>Need for File Handling in C</h3>
        <p>To store data permanently, read/write large datasets, and maintain program state between executions.</p>

        <h3>Sequential and Random Files</h3>
        <p>Sequential: Read/write data in order.<br>Random: Access data at any position.</p>

        <h3>File Handling Functions</h3>
        <ul>
            <li><b>fopen()</b>: Open a file. <i>Syntax: FILE *fopen("filename", "mode");</i></li>
            <li><b>fclose()</b>: Close a file. <i>Syntax: int fclose(FILE *fp);</i></li>
            <li><b>getc()</b>: Read a character. <i>Syntax: int getc(FILE *fp);</i></li>
            <li><b>putc()</b>: Write a character. <i>Syntax: int putc(char c, FILE *fp);</i></li>
            <li><b>fprintf()</b>: Write formatted data. <i>Syntax: int fprintf(FILE *fp, "format", args);</i></li>
            <li><b>fscanf()</b>: Read formatted data. <i>Syntax: int fscanf(FILE *fp, "format", &amp;args);</i></li>
            <li><b>getw()</b>: Read an integer. <i>Syntax: int getw(FILE *fp);</i></li>
            <li><b>putw()</b>: Write an integer. <i>Syntax: int putw(int, FILE *fp);</i></li>
            <li><b>fgets()</b>: Read a string. <i>Syntax: char *fgets(char *str, int n, FILE *fp);</i></li>
            <li><b>fputs()</b>: Write a string. <i>Syntax: int fputs(const char *str, FILE *fp);</i></li>
            <li><b>fread()</b>: Read binary data. <i>Syntax: size_t fread(void *ptr, size_t size, size_t count, FILE *fp);</i></li>
            <li><b>fwrite()</b>: Write binary data. <i>Syntax: size_t fwrite(void *ptr, size_t size, size_t count, FILE *fp);</i></li>
            <li><b>remove()</b>: Delete a file. <i>Syntax: int remove("filename");</i></li>
            <li><b>rename()</b>: Rename a file. <i>Syntax: int rename("oldname","newname");</i></li>
        </ul>

        <h3>Random Access Functions</h3>
        <ul>
            <li><b>fseek()</b>: Move file pointer to a specific location. <i>Syntax: int fseek(FILE *fp, long offset, int whence);</i></li>
            <li><b>rewind()</b>: Move file pointer to beginning. <i>Syntax: void rewind(FILE *fp);</i></li>
            <li><b>ftell()</b>: Returns current position of file pointer. <i>Syntax: long ftell(FILE *fp);</i></li>
        </ul>

        <h3>File Opening Modes</h3>
        <ul>
            <li>Read: r, r+</li>
            <li>Write: w, w+</li>
            <li>Append: a, a+</li>
        </ul>

        <h3>Steps to Work with File in C</h3>
        <ol>
            <li>Define File Pointer</li>
            <li>Open File with Required Mode</li>
            <li>Perform Read, Write, Append Operations</li>
            <li>Close the File</li>
        </ol>

        <h3>Reading Data from Files</h3>
        <p>Use functions like getc(), fgets(), fscanf(), fread() depending on data type and mode.</p>

        <h3>Writing Data on Files</h3>
        <p>Use functions like putc(), fputs(), fprintf(), fwrite() depending on data type and mode.</p>

        <h3>Appending Data to Files</h3>
        <p>Open file in append mode (a, a+) and write data at the end.</p>

        <h3>End of File (EOF)</h3>
        <p>EOF indicates no more data to read in a file. Can be checked using feof() or EOF constant.</p>
    </section>

    <section>
        <h2>Typedef Keyword in C</h2>
        <p>The <b>typedef</b> keyword is used to create a new name for an existing data type.</p>
        <pre>typedef unsigned int UINT;
UINT x = 100; // x is now an unsigned int
        </pre>
    </section>





    <footer>
        © 2025 Computer Science -JAGRIT
    </footer>


</body></html>